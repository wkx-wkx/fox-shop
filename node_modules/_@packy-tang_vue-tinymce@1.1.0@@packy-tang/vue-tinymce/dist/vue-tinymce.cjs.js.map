{"version":3,"file":"vue-tinymce.cjs.js","sources":["../src/vue-tinymce.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.js","../src/main.js"],"sourcesContent":["<script>\r\n\r\n/**\r\n * 注：编辑器二次刷新处理\r\n * 编辑器二次刷新具体效果为输入光标重置到第一行第一个字前。\r\n * 这种效果根本无法正常录入，其原因是双向绑定数据导致编辑器数据更新所致。\r\n * 根据编辑器的不同状态做标记，当标记为`INPUT`录入时，数据将不会更新至编辑器，\r\n * 从而避免二次更新的情况，具体请看`content`部分和`editor event`部分的代码。\r\n * */\r\n\r\nconst INIT = 0;\r\nconst INPUT = 1;\r\nconst CHANGED = 2;\r\n\r\nconst status = ['INIT', 'INPUT', 'CHANGED']\r\nconst changedLog = debug=>{\r\n    if(!debug) return ()=>false\r\n    console.warn(\"`@packy-tang/vue-tinymce`进入debug模式\");\r\n    return (e, _status, val, oldVal)=>console.log(`来自：%s | 状态：%s \\n %s \\n %s`, e.type, status[_status], val, oldVal)\r\n}\r\n\r\nexport default {\r\n    name: \"VueTinymce\",\r\n    model: {\r\n        prop: \"content\",\r\n        event: \"change\"\r\n    },\r\n    props: {\r\n        content: {\r\n            type: [String, Object],\r\n            default: ''\r\n        },\r\n        setup: {\r\n            type: Function,\r\n            default: function(){}\r\n        },\r\n        disabled: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        setting: {\r\n            type: Object,\r\n            default: function(){ \r\n                return {};\r\n            }\r\n        },\r\n        debug: Boolean\r\n    },\r\n    render(createElement){\r\n        if(typeof tinymce === \"undefined\"){\r\n            return createElement('div', \"tinymce is undefined\"); \r\n        }\r\n        return createElement('div', {\r\n            attrs: {\r\n                id: this.id\r\n            }\r\n        });\r\n    },\r\n    data(){\r\n        return {\r\n            id: 'vue-tinymce-'+Date.now()+Math.floor(Math.random() * 1000),\r\n            editor: null,\r\n            status: INIT,\r\n            backup: ''\r\n        }\r\n    },\r\n    watch: {\r\n        content(val, oldVal){\r\n            this.changedLog({ type: \"propsChanged\" }, this.status, val, \"--\")\r\n            if(this.status === INPUT) return;\r\n            if(!this.editor || !this.editor.initialized) return; // fix editor plugin is loading and set content will throw error.\r\n            if(val === null) return this.resetContent(\"\");\r\n            this.setContent(val);\r\n        },\r\n        disabled(val){\r\n            this.editor.setMode(val?\"readonly\":\"design\")\r\n        }\r\n    },\r\n    created(){\r\n        this.changedLog = changedLog(this.debug)\r\n        if(typeof tinymce === \"undefined\") throw new Error('tinymce undefined');\r\n    },\r\n    beforeMount () {\r\n        const setting = Object.assign({},\r\n            this.setting,\r\n            {\r\n                selector: '#'+this.id,\r\n                setup: (editor)=> {\r\n                    this.setup(editor);\r\n                    // console.log('setup');\r\n                    editor.on('init', ()=>{\r\n                        // console.log('init', this.content);\r\n                        this.setContent(this.content, editor)\r\n\r\n                        editor.on('keyup input', e=>{ //只在编辑器中打字才会触发\r\n                            this.status = INPUT       //编辑器录入文字时标记为`INPUT`状态\r\n                        })\r\n                        editor.on('SetContent', e=>{ //编辑器在插入图片和撤销/重做时触发，组件content更新数据也会导致触发\r\n                            this.status = INPUT      //编辑器在响应`setContent`方法后标记为`INPUT`状态\r\n                            this.changedLog(e, this.status, editor.getContent(), \"--\")\r\n                        })\r\n                        editor.on('Blur', e=>{\r\n                            this.status = INIT\r\n                            this.changedLog(e, this.status, editor.getContent(), \"--\")\r\n                        })\r\n                        editor.on('input keyup Change Undo Redo ExecCommand NodeChange', e=>{\r\n                            this.onChanged(e, editor)\r\n                        })\r\n                    });\r\n                }\r\n            }\r\n        );\r\n\r\n        this.editor = tinymce.createEditor(setting.selector, setting)\r\n    },\r\n    mounted(){\r\n        this.editor.targetElm = this.$el\r\n        this.editor.render()\r\n    },\r\n    updated () {\r\n        this.editor.render()\r\n    },\r\n    beforeDestroy: function(){\r\n        this.editor.remove();\r\n    },\r\n    methods: {\r\n        setContent(val, editor){\r\n            if(!editor) editor = this.editor\r\n            return editor.setContent(val)\r\n        },\r\n        resetContent(val, editor){\r\n            if(!editor) editor = this.editor\r\n            if(!!editor.resetContent) return editor.resetContent(val)\r\n            editor.setContent(val)\r\n            editor.setDirty(false)\r\n            editor.undoManager.clear()\r\n        },\r\n        onChanged(e, editor){\r\n            if(!editor) editor = this.editor\r\n            const content = editor.getContent()\r\n            this.changedLog(e, this.status, content, \"--\")\r\n            this.$emit('change', content);\r\n        }\r\n    }\r\n}\r\n</script>\r\n","'use strict';\n\nfunction normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier\n/* server only */\n, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n  if (typeof shadowMode !== 'boolean') {\n    createInjectorSSR = createInjector;\n    createInjector = shadowMode;\n    shadowMode = false;\n  } // Vue.extend constructor export interop.\n\n\n  var options = typeof script === 'function' ? script.options : script; // render functions\n\n  if (template && template.render) {\n    options.render = template.render;\n    options.staticRenderFns = template.staticRenderFns;\n    options._compiled = true; // functional template\n\n    if (isFunctionalTemplate) {\n      options.functional = true;\n    }\n  } // scopedId\n\n\n  if (scopeId) {\n    options._scopeId = scopeId;\n  }\n\n  var hook;\n\n  if (moduleIdentifier) {\n    // server build\n    hook = function hook(context) {\n      // 2.3 injection\n      context = context || // cached call\n      this.$vnode && this.$vnode.ssrContext || // stateful\n      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n      // 2.2 with runInNewContext: true\n\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__;\n      } // inject component styles\n\n\n      if (style) {\n        style.call(this, createInjectorSSR(context));\n      } // register component module identifier for async chunk inference\n\n\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier);\n      }\n    }; // used by ssr in case component is cached and beforeCreate\n    // never gets called\n\n\n    options._ssrRegister = hook;\n  } else if (style) {\n    hook = shadowMode ? function () {\n      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\n    } : function (context) {\n      style.call(this, createInjector(context));\n    };\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // register for functional component in vue file\n      var originalRender = options.render;\n\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context);\n        return originalRender(h, context);\n      };\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate;\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n    }\n  }\n\n  return script;\n}\n\nmodule.exports = normalizeComponent;\n//# sourceMappingURL=normalize-component.js.map\n","import VueTinymce from './vue-tinymce.vue'\r\nexport { VueTinymce }\r\nclass VuePlugin{\r\n    constructor(){\r\n        const { prefix } = { prefix: \"\" }\r\n        this.prefix = prefix;\r\n    }\r\n    install(Vue, options={}){\r\n        const prefix = options.prefix || this.prefix\r\n        const components = {\r\n            VueTinymce\r\n        }\r\n        Object.keys(components).forEach(key => {\r\n            const component = components[key];\r\n            Vue.component(prefix+component.name, component);\r\n        });\r\n    }\r\n}\r\nexport default new VuePlugin()"],"names":["normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","options","render","staticRenderFns","_compiled","functional","_scopeId","context","this","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","VuePlugin","[object Object]","prefix","Vue","components","VueTinymce","Object","keys","forEach","key","component","name"],"mappings":"oEAUA,4MAWA,6wDCnBA,SAASA,mBAAmBC,EAAUC,EAAOC,EAAQC,EAASC,EAAsBC,EAElFC,EAAYC,EAAgBC,EAAmBC,GACrB,kBAAfH,IACTE,EAAoBD,EACpBA,EAAiBD,EACjBA,GAAa,GAIf,IAiBII,EAjBAC,EAA4B,mBAAXT,EAAwBA,EAAOS,QAAUT,EAsD9D,GApDIF,GAAYA,EAASY,SACvBD,EAAQC,OAASZ,EAASY,OAC1BD,EAAQE,gBAAkBb,EAASa,gBACnCF,EAAQG,WAAY,EAEhBV,IACFO,EAAQI,YAAa,IAKrBZ,IACFQ,EAAQK,SAAWb,GAKjBE,GAEFK,EAAO,SAAcO,IAEnBA,EAAUA,GACVC,KAAKC,QAAUD,KAAKC,OAAOC,YAC3BF,KAAKG,QAAUH,KAAKG,OAAOF,QAAUD,KAAKG,OAAOF,OAAOC,aAGT,oBAAxBE,sBACrBL,EAAUK,qBAIRrB,GACFA,EAAMsB,KAAKL,KAAMV,EAAkBS,IAIjCA,GAAWA,EAAQO,uBACrBP,EAAQO,sBAAsBC,IAAIpB,IAMtCM,EAAQe,aAAehB,GACdT,IACTS,EAAOJ,EAAa,WAClBL,EAAMsB,KAAKL,KAAMT,EAAqBS,KAAKS,MAAMC,SAASC,cACxD,SAAUZ,GACZhB,EAAMsB,KAAKL,KAAMX,EAAeU,MAIhCP,EACF,GAAIC,EAAQI,WAAY,CAEtB,IAAIe,EAAiBnB,EAAQC,OAE7BD,EAAQC,OAAS,SAAkCmB,EAAGd,GAEpD,OADAP,EAAKa,KAAKN,GACHa,EAAeC,EAAGd,QAEtB,CAEL,IAAIe,EAAWrB,EAAQsB,aACvBtB,EAAQsB,aAAeD,EAAW,GAAGE,OAAOF,EAAUtB,GAAQ,CAACA,GAInE,OAAOR,EAGT,yBAAiBH,mBDrFjB,yPEEA,MAAMoC,UACFC,cACI,MAAMC,OAAEA,GAAW,CAAEA,OAAQ,IAC7BnB,KAAKmB,OAASA,EAElBD,QAAQE,EAAK3B,EAAQ,IACjB,MAAM0B,EAAS1B,EAAQ0B,QAAUnB,KAAKmB,OAChCE,EAAa,CACfC,WAAAA,YAEJC,OAAOC,KAAKH,GAAYI,QAAQC,IAC5B,MAAMC,EAAYN,EAAWK,GAC7BN,EAAIO,UAAUR,EAAOQ,EAAUC,KAAMD,MAIjD,SAAe,IAAIV"}